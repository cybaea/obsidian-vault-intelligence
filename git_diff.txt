diff --git a/CHANGELOG.md b/CHANGELOG.md
index cb77a46..3029f0e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -7,6 +7,15 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0
 
 ## [Unreleased]
 
+### User features
+
+### Developers
+
+
+## [1.5.0] - 2026-01-10
+
+### ðŸš€ Added
+
 
 ### User Features
 
diff --git a/build_errors.txt b/build_errors.txt
deleted file mode 100644
index e8ffb28..0000000
--- a/build_errors.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-
-> obsidian-vault-intelligence@1.4.0 build
-> tsc -noEmit -skipLibCheck && node esbuild.config.mjs production
-
-src/services/VectorStore.ts(144,41): error TS2304: Cannot find name 'expectedFloats'.
-src/services/VectorStore.ts(144,59): error TS2304: Cannot find name 'expectedFloats'.
-src/services/VectorStore.ts(145,92): error TS2304: Cannot find name 'expectedFloats'.
-src/services/VectorStore.ts(146,56): error TS2304: Cannot find name 'expectedFloats'.
diff --git a/build_log.txt b/build_log.txt
deleted file mode 100644
index cac8cd6..0000000
--- a/build_log.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-
-> obsidian-vault-intelligence@1.4.0 build
-> tsc -noEmit -skipLibCheck && node esbuild.config.mjs production
-
diff --git a/eslint_full_output.txt b/eslint_full_output.txt
deleted file mode 100644
index 2ef8769..0000000
--- a/eslint_full_output.txt
+++ /dev/null
@@ -1,10 +0,0 @@
-
-> obsidian-vault-intelligence@1.4.0 lint
-> eslint .
-
-
-/home/allane/Code/GitHub/obsidian-vault-intelligence/src/workers/embedding.worker.ts
-  396:0  error  Parsing error: Unterminated template literal
-
-âœ– 1 problem (1 error, 0 warnings)
-
diff --git a/eslint_local_output.txt b/eslint_local_output.txt
deleted file mode 100644
index e69de29..0000000
diff --git a/eslint_output.txt b/eslint_output.txt
deleted file mode 100644
index 32623f1..0000000
--- a/eslint_output.txt
+++ /dev/null
@@ -1,6 +0,0 @@
-
-/home/allane/Code/GitHub/obsidian-vault-intelligence/src/workers/embedding.worker.ts
-  163:13  error  Unexpected console statement. Only these console methods are allowed: warn, error, debug  no-console
-
-âœ– 1 problem (1 error, 0 warnings)
-
diff --git a/eslint_vectors_output.txt b/eslint_vectors_output.txt
deleted file mode 100644
index adda974..0000000
--- a/eslint_vectors_output.txt
+++ /dev/null
@@ -1,6 +0,0 @@
-
-/home/allane/Code/GitHub/obsidian-vault-intelligence/src/services/VectorStore.ts
-  346:23  warning  'message' is assigned a value but never used  @typescript-eslint/no-unused-vars
-
-âœ– 1 problem (0 errors, 1 warning)
-
diff --git a/lint_errors.txt b/lint_errors.txt
deleted file mode 100644
index a4290f2..0000000
--- a/lint_errors.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-
-> obsidian-vault-intelligence@1.4.0 lint
-> eslint .
-
-
-/home/allane/Code/GitHub/obsidian-vault-intelligence/src/services/LocalEmbeddingService.ts
-   18:12  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
-  217:17  error  Unsafe assignment of an `any` value       @typescript-eslint/no-unsafe-assignment
-
-/home/allane/Code/GitHub/obsidian-vault-intelligence/src/services/VectorStore.ts
-  140:23  warning  'dims' is assigned a value but never used                                                 @typescript-eslint/no-unused-vars
-  141:23  warning  'count' is assigned a value but never used                                                @typescript-eslint/no-unused-vars
-  144:41  error    'expectedFloats' is not defined                                                           no-undef
-  144:59  error    'expectedFloats' is not defined                                                           no-undef
-  145:92  error    'expectedFloats' is not defined                                                           no-undef
-  146:56  error    Unsafe argument of type error typed assigned to a parameter of type `number | undefined`  @typescript-eslint/no-unsafe-argument
-  146:56  error    'expectedFloats' is not defined                                                           no-undef
-
-/home/allane/Code/GitHub/obsidian-vault-intelligence/src/workers/embedding.worker.ts
-  47:91  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
-
-âœ– 10 problems (8 errors, 2 warnings)
-  2 errors and 0 warnings potentially fixable with the `--fix` option.
-
diff --git a/lint_results.txt b/lint_results.txt
deleted file mode 100644
index a4290f2..0000000
--- a/lint_results.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-
-> obsidian-vault-intelligence@1.4.0 lint
-> eslint .
-
-
-/home/allane/Code/GitHub/obsidian-vault-intelligence/src/services/LocalEmbeddingService.ts
-   18:12  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
-  217:17  error  Unsafe assignment of an `any` value       @typescript-eslint/no-unsafe-assignment
-
-/home/allane/Code/GitHub/obsidian-vault-intelligence/src/services/VectorStore.ts
-  140:23  warning  'dims' is assigned a value but never used                                                 @typescript-eslint/no-unused-vars
-  141:23  warning  'count' is assigned a value but never used                                                @typescript-eslint/no-unused-vars
-  144:41  error    'expectedFloats' is not defined                                                           no-undef
-  144:59  error    'expectedFloats' is not defined                                                           no-undef
-  145:92  error    'expectedFloats' is not defined                                                           no-undef
-  146:56  error    Unsafe argument of type error typed assigned to a parameter of type `number | undefined`  @typescript-eslint/no-unsafe-argument
-  146:56  error    'expectedFloats' is not defined                                                           no-undef
-
-/home/allane/Code/GitHub/obsidian-vault-intelligence/src/workers/embedding.worker.ts
-  47:91  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
-
-âœ– 10 problems (8 errors, 2 warnings)
-  2 errors and 0 warnings potentially fixable with the `--fix` option.
-
diff --git a/src/main.ts b/src/main.ts
index 19f7656..4712b98 100644
--- a/src/main.ts
+++ b/src/main.ts
@@ -8,16 +8,16 @@ import { logger } from "./utils/logger";
 import { IEmbeddingService } from "./services/IEmbeddingService";
 import { GeminiEmbeddingService } from "./services/GeminiEmbeddingService";
 import { LocalEmbeddingService } from "./services/LocalEmbeddingService";
+import {
+	LOCAL_EMBEDDING_MODELS
+} from "./services/ModelRegistry";
 
 export default class VaultIntelligencePlugin extends Plugin {
 	settings: VaultIntelligenceSettings;
 	geminiService: GeminiService;
-	// Store the interface, not the concrete implementation
 	embeddingService: IEmbeddingService;
 	vectorStore: VectorStore;
 
-	private debouncedOnMetadataChange: (file: TFile) => void;
-
 	private initDebouncedHandlers() {
 		// Consistently handled by VectorStore now
 	}
@@ -52,8 +52,6 @@ export default class VaultIntelligencePlugin extends Plugin {
 
 		this.initDebouncedHandlers();
 
-		// ... (Rest of the file remains the same: Event listeners, Ribbon, Commands) ...
-
 		// Background scan for new/changed files
 		this.app.workspace.onLayoutReady(() => {
 			void this.vectorStore.scanVault();
@@ -81,7 +79,7 @@ export default class VaultIntelligencePlugin extends Plugin {
 			menu.showAtMouseEvent(evt);
 		});
 
-		// Register View
+		// Register Views
 		this.registerView(
 			SIMILAR_NOTES_VIEW_TYPE,
 			(leaf) => new SimilarNotesView(leaf, this, this.vectorStore, this.geminiService, this.embeddingService)
@@ -92,7 +90,7 @@ export default class VaultIntelligencePlugin extends Plugin {
 			(leaf) => new ResearchChatView(leaf, this, this.geminiService, this.vectorStore, this.embeddingService)
 		);
 
-		// Activate View Command
+		// Commands
 		this.addCommand({
 			id: 'open-similar-notes-view',
 			name: 'Open similar notes view',
@@ -122,7 +120,6 @@ export default class VaultIntelligencePlugin extends Plugin {
 							void leaf.view.updateForFile(file);
 						}
 					}
-					// Use requestIndex even for file-open to avoid spamming on rapid switch
 					this.vectorStore.requestIndex(file);
 				}
 			})
@@ -132,14 +129,11 @@ export default class VaultIntelligencePlugin extends Plugin {
 			if (file instanceof TFile && file.extension === 'md') {
 				this.vectorStore.requestIndex(file);
 
-				// Update Similar Notes view if this is the active file
 				const activeFile = this.app.workspace.getActiveFile();
 				if (activeFile && activeFile.path === file.path) {
 					const leaves = this.app.workspace.getLeavesOfType(SIMILAR_NOTES_VIEW_TYPE);
 					for (const leaf of leaves) {
 						if (leaf.view instanceof SimilarNotesView) {
-							// We can either update immediately or wait for indexing.
-							// Usually updateForFile does its own indexing check.
 							void leaf.view.updateForFile(file);
 						}
 					}
@@ -155,7 +149,6 @@ export default class VaultIntelligencePlugin extends Plugin {
 
 		this.registerEvent(this.app.vault.on('delete', (file) => {
 			if (file instanceof TFile) {
-				// @ts-ignore
 				this.vectorStore.deleteVector(file.path);
 			}
 		}));
@@ -172,7 +165,6 @@ export default class VaultIntelligencePlugin extends Plugin {
 	onunload() {
 		if (this.vectorStore) this.vectorStore.destroy();
 
-		// Cleanup Local Worker if active
 		if (this.embeddingService instanceof LocalEmbeddingService) {
 			this.embeddingService.terminate();
 		}
@@ -180,32 +172,25 @@ export default class VaultIntelligencePlugin extends Plugin {
 		logger.info("Vault Intelligence Plugin Unloaded");
 	}
 
-	// ... (rest of class: loadSettings, saveSettings, activateView) ...
 	async loadSettings() {
 		this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData() as Partial<VaultIntelligenceSettings>);
 
 		// Sanity check: Ensure dimensions match presets if using a local provider
-		// This fixes "poisoned" settings where a model change didn't update the dimension
 		if (this.settings.embeddingProvider === 'local') {
-			const { MODELS } = await import("./settings/sections/models");
-			if (this.settings.embeddingModel === MODELS.SMALL && this.settings.embeddingDimension !== 256) {
-				logger.warn(`Fixing stale dimension for Small model: ${this.settings.embeddingDimension} -> 256`);
-				this.settings.embeddingDimension = 256;
-				await this.saveData(this.settings);
-			} else if (this.settings.embeddingModel === MODELS.BALANCED && this.settings.embeddingDimension !== 384) {
-				logger.warn(`Fixing stale dimension for Balanced model: ${this.settings.embeddingDimension} -> 384`);
-				this.settings.embeddingDimension = 384;
-				await this.saveData(this.settings);
-			} else if (this.settings.embeddingModel === MODELS.ADVANCED && this.settings.embeddingDimension !== 768) {
-				logger.warn(`Fixing stale dimension for Advanced model: ${this.settings.embeddingDimension} -> 768`);
-				this.settings.embeddingDimension = 768;
+			const modelId = this.settings.embeddingModel;
+			const modelDef = LOCAL_EMBEDDING_MODELS.find(m => m.id === modelId);
+
+			if (modelDef?.dimensions && this.settings.embeddingDimension !== modelDef.dimensions) {
+				logger.warn(`Fixing stale dimension for ${modelDef.label}: ${this.settings.embeddingDimension} -> ${modelDef.dimensions}`);
+				this.settings.embeddingDimension = modelDef.dimensions;
 				await this.saveData(this.settings);
 			}
 
 			// Migration: v1.5 -> v1 (v1.5 seems to be broken/unavailable in Xenova repo)
-			if (this.settings.embeddingModel === 'Xenova/nomic-embed-text-v1.5') {
-				logger.info(`Migrating model from v1.5 to v1: ${this.settings.embeddingModel} -> ${MODELS.ADVANCED}`);
-				this.settings.embeddingModel = MODELS.ADVANCED;
+			if (modelId === 'Xenova/nomic-embed-text-v1.5') {
+				const nomicV1 = 'Xenova/nomic-embed-text-v1';
+				logger.info(`Migrating model from v1.5 to v1: ${modelId} -> ${nomicV1}`);
+				this.settings.embeddingModel = nomicV1;
 				this.settings.embeddingDimension = 768;
 				await this.saveData(this.settings);
 			}
@@ -217,12 +202,8 @@ export default class VaultIntelligencePlugin extends Plugin {
 		if (logger) logger.setLevel(this.settings.logLevel);
 		if (this.geminiService) this.geminiService.updateSettings(this.settings);
 
-		// Re-initialize handlers to pick up change in indexingDelayMs
 		this.initDebouncedHandlers();
 
-		// Note: We don't hot-swap embedding services yet. 
-		// The settings tab warns the user to restart if they change providers.
-
 		if (this.vectorStore) {
 			this.vectorStore.updateSettings(this.settings);
 
diff --git a/src/services/AgentService.ts b/src/services/AgentService.ts
index 84568c9..0b6b079 100644
--- a/src/services/AgentService.ts
+++ b/src/services/AgentService.ts
@@ -5,9 +5,8 @@ import { TFile, App, requestUrl, MarkdownView } from "obsidian";
 import { Type, Part, Tool, Content, FunctionDeclaration } from "@google/genai";
 import { logger } from "../utils/logger";
 import { VaultIntelligenceSettings, DEFAULT_SETTINGS } from "../settings";
-
-const CHARS_PER_TOKEN_ESTIMATE = 4; // Standard approximation for English text
-const CONTEXT_SAFETY_MARGIN = 0.8;  // Reserve 20% for output and "Thinking" overhead
+import { SEARCH_CONSTANTS } from "../constants";
+import { ScoringStrategy } from "./ScoringStrategy";
 
 export interface ChatMessage {
     role: "user" | "model" | "system";
@@ -29,10 +28,12 @@ export class AgentService {
     private app: App;
     private settings: VaultIntelligenceSettings;
 
+    private scoringStrategy: ScoringStrategy;
+
     constructor(
-        app: App, 
-        gemini: GeminiService, 
-        vectorStore: VectorStore, 
+        app: App,
+        gemini: GeminiService,
+        vectorStore: VectorStore,
         embeddingService: IEmbeddingService, // Injected here
         settings: VaultIntelligenceSettings
     ) {
@@ -41,6 +42,7 @@ export class AgentService {
         this.vectorStore = vectorStore;
         this.embeddingService = embeddingService;
         this.settings = settings;
+        this.scoringStrategy = new ScoringStrategy();
     }
 
     private getTools(): Tool[] {
@@ -79,12 +81,12 @@ export class AgentService {
         // 3. Google Search (Sub-Agent)
         const googleSearch: FunctionDeclaration = {
             name: "google_search",
-             description: "Perform a Google search to find the latest real-world information, facts, dates, or news.",
-             parameters: {
-                 type: Type.OBJECT,
-                 properties: { query: { type: Type.STRING } },
-                 required: ["query"]
-             }
+            description: "Perform a Google search to find the latest real-world information, facts, dates, or news.",
+            parameters: {
+                type: Type.OBJECT,
+                properties: { query: { type: Type.STRING } },
+                required: ["query"]
+            }
         };
 
         const toolsList: FunctionDeclaration[] = [vaultSearch, urlReader, googleSearch];
@@ -97,9 +99,9 @@ export class AgentService {
                 parameters: {
                     type: Type.OBJECT,
                     properties: {
-                        task: { 
-                            type: Type.STRING, 
-                            description: "The math problem or logic task to solve (e.g., 'Calculate the 50th Fibonacci number')." 
+                        task: {
+                            type: Type.STRING,
+                            description: "The math problem or logic task to solve (e.g., 'Calculate the 50th Fibonacci number')."
                         }
                     },
                     required: ["task"]
@@ -119,12 +121,11 @@ export class AgentService {
     private async assembleContext(results: VaultSearchResult[], query: string): Promise<string> {
         // 1. Calculate Budget based on Settings
         const totalTokens = this.settings.contextWindowTokens || DEFAULT_SETTINGS.contextWindowTokens;
-        const totalCharBudget = Math.floor(totalTokens * CHARS_PER_TOKEN_ESTIMATE * CONTEXT_SAFETY_MARGIN);
-        
+        const totalCharBudget = Math.floor(totalTokens * SEARCH_CONSTANTS.CHARS_PER_TOKEN_ESTIMATE * SEARCH_CONSTANTS.CONTEXT_SAFETY_MARGIN);
+
         // 2. Define "Starvation Protection" limit
         // No single document should take up more than 25% of the budget if there are other results.
-        // For Gemini 3 (1M tokens), this is still a massive ~1M chars per doc, so it rarely triggers.
-        const singleDocSoftLimit = Math.floor(totalCharBudget * 0.25);
+        const singleDocSoftLimit = Math.floor(totalCharBudget * SEARCH_CONSTANTS.SINGLE_DOC_SOFT_LIMIT_RATIO);
 
         logger.debug(`[Context] Budget: ${totalCharBudget} chars. Soft Cap: ${singleDocSoftLimit} chars.`);
 
@@ -160,12 +161,12 @@ export class AgentService {
                     // Fallback: Use Smart Windowing (clipping)
                     // We take a slice of the document centered on the keyword
                     logger.debug(`[Context] Clipping file ${file.path} (Size: ${content.length}).`);
-                    
+
                     // Calculate how much space we can reasonably give this doc
                     // (Either the remaining budget OR the soft limit, whichever is smaller)
                     const availableSpace = Math.min(singleDocSoftLimit, totalCharBudget - currentUsage);
-                    
-                    if (availableSpace < 500) continue; // Skip if too little space left
+
+                    if (availableSpace < SEARCH_CONSTANTS.MIN_DOC_CONTEXT_CHARS) continue; // Skip if too little space left
 
                     if (doc.isKeywordMatch) {
                         // Center window on match
@@ -206,7 +207,7 @@ export class AgentService {
                 // Safety check for query
                 const rawQuery = args.query;
                 const query = typeof rawQuery === 'string' ? rawQuery : JSON.stringify(rawQuery);
-                
+
                 logger.info(`Delegating search to sub-agent for: ${query}`);
                 const searchResult = await this.gemini.searchWithGrounding(query);
                 return { result: searchResult };
@@ -228,26 +229,26 @@ export class AgentService {
             }
 
             logger.info(`[VaultSearch] Starting search for: "${query}"`);
-            
+
             // 1. Vector Search (Semantic)
             const embedding = await this.embeddingService.embedQuery(query);
             const rawLimit = this.settings?.vaultSearchResultsLimit ?? DEFAULT_SETTINGS.vaultSearchResultsLimit;
             const limit = Math.max(0, Math.trunc(rawLimit));
-            
-            let vectorResults = this.vectorStore.findSimilar(embedding, limit, 0.35);
+
+            let vectorResults = this.vectorStore.findSimilar(embedding, limit, SEARCH_CONSTANTS.VECTOR_MIN_RELEVANCE);
             logger.info(`[VaultSearch] Vector search returned ${vectorResults.length} candidates.`);
 
             // 2. Keyword Search (Hybrid: Exact + Bag-of-Words)
             const keywordResults: VaultSearchResult[] = [];
-            
-            if (query.length > 2) { 
+
+            if (query.length > 2) {
                 const files = this.app.vault.getMarkdownFiles();
-                
+
                 // FIX: Token Cleaning
                 // 1. Remove quotes
                 // 2. Remove boolean operators (OR, AND) which the Agent likes to use
                 // 3. Filter short words
-                const cleanQuery = query.replace(/["'()]/g, " "); 
+                const cleanQuery = query.replace(/["'()]/g, " ");
                 const tokens = cleanQuery.split(/\s+/)
                     .map(t => t.trim())
                     .filter(t => t.length > 2 && t !== "or" && t !== "and");
@@ -255,18 +256,19 @@ export class AgentService {
                 const isMultiWord = tokens.length > 1;
 
                 let keywordMatchesFound = 0;
-                const MAX_KEYWORD_MATCHES = 100; 
+                const MAX_KEYWORD_MATCHES = 100;
 
                 for (const file of files) {
                     if (keywordMatchesFound >= MAX_KEYWORD_MATCHES) break;
 
                     const titleLower = file.basename.toLowerCase();
-                    
+
                     // A. Title Exact Match
-                    if (titleLower.includes(query)) {
-                        keywordResults.push({ path: file.path, score: 1.2, isKeywordMatch: true, isTitleMatch: true });
+                    const titleScore = this.scoringStrategy.calculateTitleScore(titleLower, query);
+                    if (titleScore !== null) {
+                        keywordResults.push({ path: file.path, score: titleScore, isKeywordMatch: true, isTitleMatch: true });
                         keywordMatchesFound++;
-                        continue; 
+                        continue;
                     }
 
                     // B. Body Scan
@@ -275,50 +277,16 @@ export class AgentService {
                         const contentLower = content.toLowerCase();
 
                         // B1. Exact Phrase Match (Highest Body Score)
-                        if (contentLower.includes(query)) {
-                            keywordResults.push({ path: file.path, score: 0.85, isKeywordMatch: true, isTitleMatch: false });
+                        const bodyExactScore = this.scoringStrategy.calculateExactBodyScore(contentLower, query);
+                        if (bodyExactScore !== null) {
+                            keywordResults.push({ path: file.path, score: bodyExactScore, isKeywordMatch: true, isTitleMatch: false });
                             keywordMatchesFound++;
                             continue;
                         }
 
                         // B2. "Bag of Words" Match (Flexible)
                         if (isMultiWord) {
-                            let hits = 0;
-                            for (const token of tokens) {
-                                // Stemming checks
-                                let match = false;
-                                if (contentLower.includes(token)) {
-                                    match = true;
-                                } else if (token.endsWith('s') && contentLower.includes(token.slice(0, -1))) {
-                                    match = true;
-                                } else if (token.endsWith('ing') && contentLower.includes(token.slice(0, -3))) {
-                                    match = true;
-                                } else if (token.endsWith('ed') && contentLower.includes(token.slice(0, -2))) { // added 'ed' check
-                                    match = true;
-                                }
-                                
-                                if (match) hits++;
-                            }
-
-                            const matchRatio = hits / tokens.length;
-                            let fuzzyScore = 0;
-
-                            // FIX: Adaptive Thresholds
-                            // Scenario 1: Short Query (<4 tokens) -> Strict (Need high overlap)
-                            if (tokens.length < 4) {
-                                if (matchRatio > 0.6) {
-                                    fuzzyScore = 0.4 + (matchRatio * 0.3);
-                                }
-                            } 
-                            // Scenario 2: Long Query (>=4 tokens) -> Loose (Synonym stuffing)
-                            // If we hit at least 2 distinct words, or 30% of the query, it's relevant.
-                            else {
-                                if (hits >= 2 || matchRatio > 0.3) {
-                                    // Score based on raw hit count, capped at 0.75
-                                    // This allows "financial firm bankruptcy" to match "financial firms ... collapsed ... bankruptcy"
-                                    fuzzyScore = Math.min(0.4 + (hits * 0.08), 0.75);
-                                }
-                            }
+                            const fuzzyScore = this.scoringStrategy.calculateFuzzyScore(tokens, contentLower);
 
                             if (fuzzyScore > 0) {
                                 keywordResults.push({ path: file.path, score: fuzzyScore, isKeywordMatch: true, isTitleMatch: false });
@@ -341,12 +309,15 @@ export class AgentService {
             // Add/Merge Keyword Results
             for (const res of keywordResults) {
                 const existing = mergedMap.get(res.path);
-                
+
                 if (existing !== undefined) {
                     logger.debug(`[VaultSearch] Boosting score for: ${res.path} (Vector + Keyword)`);
-                    existing.score += 0.3; 
+                    existing.score = this.scoringStrategy.boostHybridResult(existing.score, {
+                        score: res.score,
+                        isKeywordMatch: !!res.isKeywordMatch,
+                        isTitleMatch: !!res.isTitleMatch
+                    });
                     existing.isKeywordMatch = true;
-                    if (res.isTitleMatch) existing.score += 0.5; 
                 } else {
                     mergedMap.set(res.path, res);
                 }
@@ -354,10 +325,10 @@ export class AgentService {
 
             const finalResults = Array.from(mergedMap.values())
                 .sort((a, b) => b.score - a.score)
-                .slice(0, limit); 
+                .slice(0, limit);
 
             logger.info(`[VaultSearch] Final ranked results: ${finalResults.length} docs.`);
-            
+
             const topMatch = finalResults[0];
             if (topMatch) {
                 logger.info(`[VaultSearch] Top match: ${topMatch.path} (Score: ${topMatch.score.toFixed(2)})`);
@@ -367,16 +338,16 @@ export class AgentService {
 
             // 4. Build Context
             const context = await this.assembleContext(finalResults, query);
-             
-             if (!context) return { result: "No relevant notes found or context budget exceeded." };
-             return { result: context };
+
+            if (!context) return { result: "No relevant notes found or context budget exceeded." };
+            return { result: context };
         }
 
         if (name === "read_url") {
             try {
                 const url = args.url as string;
                 const res = await requestUrl({ url });
-                return { result: res.text.substring(0, 5000) };
+                return { result: res.text.substring(0, SEARCH_CONSTANTS.TOOL_RESPONSE_TRUNCATE_LIMIT) };
             } catch (e: unknown) {
                 const message = e instanceof Error ? e.message : String(e);
                 return { error: `Failed to read URL: ${message}` };
@@ -392,7 +363,7 @@ export class AgentService {
 
                 const task = args.task as string;
                 logger.info(`Delegating to Code Sub-Agent (${this.settings.codeModel}): ${task}`);
-                
+
                 // Call GeminiService
                 const result = await this.gemini.solveWithCode(task);
                 return { result: result };
@@ -436,29 +407,29 @@ export class AgentService {
 
         const currentDate = new Date().toDateString();
         const rawSystemInstruction = this.settings.systemInstruction || DEFAULT_SETTINGS.systemInstruction;
-        
+
         // Replace {{DATE}} placeholder
         const systemInstruction = rawSystemInstruction.replace("{{DATE}}", currentDate);
 
         // Pass dynamic systemInstruction to the service
         const chat = await this.gemini.startChat(formattedHistory, this.getTools(), systemInstruction);
-        
+
         try {
             let result = await chat.sendMessage({ message: message });
-            
+
             let loops = 0;
             const maxLoops = this.settings?.maxAgentSteps ?? DEFAULT_SETTINGS.maxAgentSteps;
 
             while (loops < maxLoops) {
-                const calls = result.functionCalls; 
-                
+                const calls = result.functionCalls;
+
                 if (calls && calls.length > 0) {
                     const toolPromises = calls.map(async (call) => {
                         if (!call.name) return null;
-                        
+
                         const args = call.args || {};
                         const functionResponse = await this.executeFunction(call.name, args);
-                        
+
                         return {
                             functionResponse: {
                                 name: call.name,
@@ -472,7 +443,7 @@ export class AgentService {
                     if (completedParts.length > 0) {
                         result = await chat.sendMessage({ message: completedParts });
                     } else {
-                        break; 
+                        break;
                     }
                 } else {
                     break;
diff --git a/src/services/LocalEmbeddingService.ts b/src/services/LocalEmbeddingService.ts
index 185cade..6d36d70 100644
--- a/src/services/LocalEmbeddingService.ts
+++ b/src/services/LocalEmbeddingService.ts
@@ -2,6 +2,7 @@ import { IEmbeddingService, EmbeddingPriority } from "./IEmbeddingService";
 import { Plugin, Notice, Platform, requestUrl } from "obsidian";
 import { VaultIntelligenceSettings } from "../settings/types";
 import { logger } from "../utils/logger";
+import { WORKER_CONSTANTS } from "../constants";
 
 import EmbeddingWorker from "../workers/embedding.worker";
 
@@ -32,6 +33,8 @@ interface ConfigureMessage {
     type: 'configure';
     numThreads: number;
     simd: boolean;
+    cdnUrl: string;
+    version: string;
 }
 
 export class LocalEmbeddingService implements IEmbeddingService {
@@ -104,8 +107,8 @@ export class LocalEmbeddingService implements IEmbeddingService {
             const instance = new EmbeddingWorker({ name: 'VaultIntelligenceWorker' });
             this.worker = instance;
 
-            instance.onmessage = (e: MessageEvent) => this._onMessage(e);
-            instance.onerror = (e: ErrorEvent) => {
+            this.worker.onmessage = (e: MessageEvent) => this._onMessage(e);
+            this.worker.onerror = (e: ErrorEvent) => {
                 logger.error("[LocalEmbedding] Worker Error:", e);
                 new Notice("Local worker crashed.");
             };
@@ -119,7 +122,9 @@ export class LocalEmbeddingService implements IEmbeddingService {
             instance.postMessage({
                 type: 'configure',
                 numThreads,
-                simd
+                simd,
+                cdnUrl: WORKER_CONSTANTS.WASM_CDN_URL,
+                version: WORKER_CONSTANTS.WASM_VERSION
             } as ConfigureMessage);
 
             logger.info(`Local embedding worker initialized (${numThreads} threads, SIMD: ${simd}).`);
@@ -134,8 +139,10 @@ export class LocalEmbeddingService implements IEmbeddingService {
         this.worker.postMessage({
             type: 'configure',
             numThreads: this.settings.embeddingThreads,
-            simd: !Platform.isMobile
-        });
+            simd: !Platform.isMobile,
+            cdnUrl: WORKER_CONSTANTS.WASM_CDN_URL,
+            version: WORKER_CONSTANTS.WASM_VERSION
+        } as ConfigureMessage);
     }
 
     private async _onMessage(event: MessageEvent) {
@@ -173,8 +180,9 @@ export class LocalEmbeddingService implements IEmbeddingService {
             if (status === 'success' && output) {
                 promise.resolve(output);
             } else {
-                logger.error(`[LocalEmbedding] Worker task ${id} failed:`, error);
-                promise.reject(error || "Unknown worker error");
+                const message = error || "Unknown worker error";
+                logger.error(`[LocalEmbedding] Worker task ${id} failed:`, message);
+                promise.reject(message);
             }
             this.pendingRequests.delete(id);
         }
@@ -280,11 +288,12 @@ export class LocalEmbeddingService implements IEmbeddingService {
                 headers: response.headers,
                 body: response.arrayBuffer,
             }, [response.arrayBuffer]); // Use transferrable
-        } catch (e) {
+        } catch (e: unknown) {
+            const message = e instanceof Error ? e.message : String(e);
             this.worker.postMessage({
                 type: 'fetch_response',
                 requestId: data.requestId,
-                error: e instanceof Error ? e.message : String(e),
+                error: message,
             });
         }
     }
diff --git a/src/services/VectorStore.ts b/src/services/VectorStore.ts
index cdc1065..f255da9 100644
--- a/src/services/VectorStore.ts
+++ b/src/services/VectorStore.ts
@@ -3,14 +3,16 @@ import { IEmbeddingService, EmbeddingPriority } from "./IEmbeddingService";
 import { GeminiService } from "./GeminiService";
 import { logger } from "../utils/logger";
 import { VaultIntelligenceSettings } from "../settings";
+import { EMBEDDING_CONSTANTS } from "../constants";
 
 const DATA_DIR = "data";
 const INDEX_FILE = "index.json";
 const VECTORS_FILE = "vectors.bin";
 
 interface VectorEntry {
-    ids: number[]; // Changed from 'id' to 'ids'
+    ids: number[];
     mtime: number;
+    size: number;
     path: string;
 }
 
@@ -30,18 +32,15 @@ export class VectorStore {
     private activeTimers: Set<ReturnType<typeof setTimeout>> = new Set();
     private settings: VaultIntelligenceSettings;
     private consecutiveErrors = 0;
-    private readonly MAX_ERRORS_BEFORE_BACKOFF = 5;
 
     // Data Store
     private index: VectorIndex;
     private vectors: Float32Array = new Float32Array(0);
-    // NEW: In-memory reverse index for fast lookups (Vector ID -> File Path)
     private vectorIdToPath: string[] = [];
 
     // Concurrency Control
     private requestQueue: (() => Promise<void>)[] = [];
     private activeRequests = 0;
-    private readonly MAX_CONCURRENT_REQUESTS = 1;
     private baseDelayMs: number;
     private currentDelayMs: number;
     private minSimilarityScore: number;
@@ -63,11 +62,7 @@ export class VectorStore {
             files: {}
         };
 
-        this.initDebouncedIndex();
-    }
-
-    private initDebouncedIndex() {
-        // No longer using Obsidian debounce for per-file indexing
+        this.updateSettings(settings);
     }
 
     public setEmbeddingService(service: IEmbeddingService) {
@@ -76,15 +71,12 @@ export class VectorStore {
 
     public updateSettings(settings: VaultIntelligenceSettings) {
         this.settings = settings;
-        this.baseDelayMs = settings.queueDelayMs || 300;
+        this.baseDelayMs = settings.queueDelayMs || EMBEDDING_CONSTANTS.DEFAULT_QUEUE_DELAY_MS;
         this.minSimilarityScore = settings.minSimilarityScore ?? 0.5;
         this.similarNotesLimit = settings.similarNotesLimit ?? 5;
         if (!this.isBackingOff) {
             this.currentDelayMs = this.baseDelayMs;
         }
-
-        // Re-initialize debounce if delay changed
-        this.initDebouncedIndex();
     }
 
     private getDataPath(filename: string): string {
@@ -103,24 +95,22 @@ export class VectorStore {
         const indexPath = this.getDataPath(INDEX_FILE);
         const vectorsPath = this.getDataPath(VECTORS_FILE);
 
-        // 1. Load Index
         if (await this.plugin.app.vault.adapter.exists(indexPath)) {
             try {
                 const indexStr = await this.plugin.app.vault.adapter.read(indexPath);
-                // Cast to unknown first for safe processing
                 const loadedRaw = JSON.parse(indexStr) as Record<string, unknown>;
 
-                // Compatibility Update: Convert old 'id' entries to 'ids' if needed
-                const files = loadedRaw.files;
-                if (files && typeof files === 'object' && files !== null && !Array.isArray(files)) {
-                    const filesMap = files as Record<string, Record<string, unknown>>;
-                    for (const key in filesMap) {
-                        const entry = filesMap[key];
-                        if (entry && typeof entry === 'object' && !Array.isArray(entry)) {
-                            if ('id' in entry && !('ids' in entry)) {
-                                entry.ids = [entry.id];
-                                delete entry.id;
-                            }
+                // Compatibility Update
+                const files = loadedRaw.files as Record<string, Record<string, unknown>> | undefined;
+                if (files && typeof files === 'object') {
+                    for (const key in files) {
+                        const entry = files[key] as Record<string, unknown>;
+                        if (entry && 'id' in entry && !('ids' in entry)) {
+                            entry.ids = [entry.id];
+                            delete entry.id;
+                        }
+                        if (entry && !('size' in entry)) {
+                            entry.size = 0; // Default for old indices
                         }
                     }
                 }
@@ -130,9 +120,8 @@ export class VectorStore {
                 const dimChanged = this.index.dimensions !== this.embeddingService.dimensions;
 
                 if (modelChanged || dimChanged) {
-                    const reason = modelChanged ? "Model changed" : "Dimension changed";
-                    logger.warn(`${reason}. Wiping index to rebuild.`);
-                    await this.reindexVault(); // Use reindex logic
+                    logger.warn(`${modelChanged ? "Model" : "Dimension"} changed. Wiping index.`);
+                    await this.reindexVault();
                     return;
                 }
                 logger.info(`Loaded index for ${Object.keys(this.index.files).length} files.`);
@@ -142,22 +131,17 @@ export class VectorStore {
             }
         }
 
-        // 2. Load Binary Vectors
         if (await this.plugin.app.vault.adapter.exists(vectorsPath)) {
             try {
                 const buffer = await this.plugin.app.vault.adapter.readBinary(vectorsPath);
-                // Important: Only use the portion that matches the index
                 const dims = this.index.dimensions;
                 const count = Object.values(this.index.files).reduce((acc, f) => acc + f.ids.length, 0);
                 const expectedFloats = count * dims;
 
                 const rawVectors = new Float32Array(buffer);
-                if (rawVectors.length > expectedFloats && expectedFloats > 0) {
-                    logger.warn(`Trimming bloated vector buffer: ${rawVectors.length} -> ${expectedFloats} floats.`);
-                    this.vectors = rawVectors.slice(0, expectedFloats);
-                } else {
-                    this.vectors = rawVectors;
-                }
+                this.vectors = rawVectors.length > expectedFloats && expectedFloats > 0
+                    ? rawVectors.slice(0, expectedFloats)
+                    : rawVectors;
 
                 this.normalizeAllVectors();
                 logger.info(`Loaded vector buffer: ${this.vectors.length} floats.`);
@@ -167,7 +151,6 @@ export class VectorStore {
             }
         }
 
-        // 3. Rebuild Reverse Index
         this.rebuildReverseIndex();
     }
 
@@ -189,11 +172,9 @@ export class VectorStore {
 
         for (const path in this.index.files) {
             const entry = this.index.files[path];
-            if (entry && entry.ids) {
+            if (entry) {
                 for (const id of entry.ids) {
-                    if (id < numVectors) {
-                        this.vectorIdToPath[id] = path;
-                    }
+                    if (id < numVectors) this.vectorIdToPath[id] = path;
                 }
             }
         }
@@ -201,24 +182,18 @@ export class VectorStore {
 
     private normalizeAllVectors() {
         const dims = this.index.dimensions;
-        // Check alignment
         if (this.vectors.length % dims !== 0) {
-            logger.warn("Vector buffer size alignment error. Truncating.");
-            const alignedSize = Math.floor(this.vectors.length / dims) * dims;
-            this.vectors = this.vectors.subarray(0, alignedSize);
+            this.vectors = this.vectors.subarray(0, Math.floor(this.vectors.length / dims) * dims);
         }
-
-        const count = this.vectors.length / dims;
-        for (let i = 0; i < count; i++) {
-            const start = i * dims;
-            this.normalizeInPlace(this.vectors.subarray(start, start + dims));
+        for (let i = 0; i < this.vectors.length / dims; i++) {
+            this.normalizeInPlace(this.vectors.subarray(i * dims, (i + 1) * dims));
         }
     }
 
     private normalizeInPlace(vec: Float32Array | number[]) {
         let mag = 0;
         for (let i = 0; i < vec.length; i++) mag += vec[i]! * vec[i]!;
-        if (mag === 0 || Math.abs(mag - 1) < 1e-6) return;
+        if (mag === 0 || Math.abs(mag - 1) < EMBEDDING_CONSTANTS.NORMALIZATION_PRECISION) return;
         const invMag = 1 / Math.sqrt(mag);
         for (let i = 0; i < vec.length; i++) vec[i]! *= invMag;
     }
@@ -234,10 +209,6 @@ export class VectorStore {
                 await this.ensureDataDir();
                 const indexPath = this.getDataPath(INDEX_FILE);
                 const vectorsPath = this.getDataPath(VECTORS_FILE);
-
-                // No logic to shrink vectors here beyond relying on deletes to maintain compactness
-
-                // Compact the buffer for saving
                 const count = this.vectorIdToPath.length;
                 const dims = this.index.dimensions;
                 const activeData = this.vectors.slice(0, count * dims);
@@ -252,9 +223,8 @@ export class VectorStore {
             }
         };
 
-        if (immediate) {
-            await doSave();
-        } else {
+        if (immediate) await doSave();
+        else {
             this.isDirty = true;
             this.saveDebounceTimer = setTimeout(() => {
                 this.saveDebounceTimer = null;
@@ -266,19 +236,18 @@ export class VectorStore {
 
     public scanVault(fullScan = false) {
         if (!this.gemini.isReady()) {
-            logger.warn("Gemini Service not ready. Skipping vault scan.");
+            logger.warn("Gemini Service not ready. Skipping scan.");
             return;
         }
 
-        // Automatic re-index if dimensions changed mid-session
         const serviceDims = this.embeddingService.dimensions;
         if (this.index.dimensions > 0 && this.index.dimensions !== serviceDims) {
-            logger.warn(`Dimension mismatch detected during scan (${this.index.dimensions} vs ${serviceDims}). Re-indexing...`);
+            logger.warn("Dimension mismatch. Re-indexing...");
             void this.reindexVault();
             return;
         }
 
-        logger.info("Starting vault scan...");
+        logger.info("Scanning vault...");
         const files = this.plugin.app.vault.getMarkdownFiles();
         let changedCount = 0;
 
@@ -292,10 +261,9 @@ export class VectorStore {
 
         for (const file of files) {
             const entry = this.index.files[file.path];
-            const isNew = !entry;
-            const isModified = entry && entry.mtime !== file.stat.mtime;
+            const isModified = !entry || entry.mtime !== file.stat.mtime || entry.size !== file.stat.size;
 
-            if (fullScan || isNew || isModified) {
+            if (fullScan || isModified) {
                 this.enqueueIndex(file);
                 changedCount++;
             }
@@ -304,22 +272,15 @@ export class VectorStore {
         if (changedCount > 0) {
             logger.info(`Found ${changedCount} files to update/remove.`);
             new Notice(`Vault intelligence: updating ${changedCount} files`);
-        } else {
-            logger.info("Vault scan complete. No changes.");
         }
     }
 
     public async reindexVault() {
-        logger.info("Re-indexing vault...");
-        new Notice("Vault intelligence: re-indexing vault for new model");
-
         this.isReindexing = true;
-        this.requestQueue = []; // Clear pending requests for old model
-
+        this.requestQueue = [];
         this.resetIndex();
-        await this.saveVectors(); // Wipe disk
+        await this.saveVectors(true);
         this.scanVault(true);
-
         this.isReindexing = false;
     }
 
@@ -331,12 +292,10 @@ export class VectorStore {
     }
 
     private async processQueue() {
-        if (this.activeRequests >= this.MAX_CONCURRENT_REQUESTS) return;
-        if (this.requestQueue.length === 0) return;
-        if (this.isBackingOff) return;
+        if (this.activeRequests >= EMBEDDING_CONSTANTS.MAX_CONCURRENT_REQUESTS || this.requestQueue.length === 0 || this.isBackingOff) return;
 
-        if (this.consecutiveErrors >= this.MAX_ERRORS_BEFORE_BACKOFF) {
-            logger.error(`[VectorStore] Too many consecutive errors. Backing off.`);
+        if (this.consecutiveErrors >= EMBEDDING_CONSTANTS.MAX_ERRORS_BEFORE_BACKOFF) {
+            logger.error(`Too many errors. Backing off.`);
             this.triggerBackoff();
             return;
         }
@@ -353,7 +312,7 @@ export class VectorStore {
                 }
             } catch (e) {
                 this.consecutiveErrors++;
-                logger.error(`[VectorStore] Error processing queue task (error ${this.consecutiveErrors}/${this.MAX_ERRORS_BEFORE_BACKOFF}):`, e);
+                logger.error(`Queue error (${this.consecutiveErrors}/${EMBEDDING_CONSTANTS.MAX_ERRORS_BEFORE_BACKOFF}):`, e);
             } finally {
                 this.activeRequests--;
                 const timer = setTimeout(() => {
@@ -366,71 +325,40 @@ export class VectorStore {
     }
 
     public async getOrIndexFile(file: TFile): Promise<number[] | null> {
-        // 1. Try cache
         const vector = this.getVector(file.path);
         if (vector) return vector;
-
-        // 2. Index immediately (High priority)
-        // This handles cases where the background scanner hasn't reached this file yet
-        logger.debug(`File not indexed, performing priority indexing: ${file.path}`);
         const embeddings = await this.indexFileImmediate(file, 'high');
         return embeddings && embeddings.length > 0 ? embeddings[0]! : null;
     }
 
-    public indexFile(file: TFile) {
-        this.enqueueIndex(file);
-    }
-
-    /**
-     * Consolidates all indexing requests.
-     * Uses a per-file timer to debounce frequent updates (e.g. typing).
-     */
     public requestIndex(file: TFile, delayMs?: number) {
         if (!file || file.extension !== 'md') return;
 
-        // Clear existing timer for this file
         const existingTimer = this.pendingIndexTimers.get(file.path);
         if (existingTimer) {
             clearTimeout(existingTimer);
             this.activeTimers.delete(existingTimer);
         }
 
-        const waitTime = delayMs ?? this.settings.indexingDelayMs ?? 5000;
-
-        logger.debug(`Requesting index for ${file.path} (delay: ${waitTime}ms)`);
+        const waitTime = delayMs ?? this.settings.indexingDelayMs ?? EMBEDDING_CONSTANTS.DEFAULT_INDEXING_DELAY_MS;
 
         const timer = setTimeout(() => {
             this.pendingIndexTimers.delete(file.path);
             this.activeTimers.delete(timer);
-            this.indexFile(file);
+            this.enqueueIndex(file);
         }, waitTime);
 
         this.pendingIndexTimers.set(file.path, timer);
         this.activeTimers.add(timer);
     }
 
-    public debouncedIndexFile(file: TFile) {
-        // Compatibility: Route to requestIndex
-        this.requestIndex(file);
-    }
-
     private async indexFileImmediate(file: TFile, priority: EmbeddingPriority = 'low'): Promise<number[][] | null> {
         if (!file || file.extension !== 'md') return null;
 
-        // Removed gemini.isReady() check to allow local models to work 
-        // without a Gemini API key. embeddingService will handle its own readiness.
-
-        // Double check against existing to avoid duplicate work if queued multiple times
         const entry = this.index.files[file.path];
-        if (entry && entry.mtime === file.stat.mtime) {
-            // If already indexed, we might still want to return the vectors
+        if (entry && entry.mtime === file.stat.mtime && entry.size === file.stat.size) {
             const dims = this.index.dimensions;
-            const vectors: number[][] = [];
-            for (const id of entry.ids) {
-                const start = id * dims;
-                vectors.push(Array.from(this.vectors.slice(start, start + dims)));
-            }
-            return vectors;
+            return entry.ids.map(id => Array.from(this.vectors.slice(id * dims, (id + 1) * dims)));
         }
 
         try {
@@ -438,97 +366,64 @@ export class VectorStore {
             const cache = this.plugin.app.metadataCache.getFileCache(file);
             let textToEmbed = content;
 
-            // Simple frontmatter removal / title extraction
-            if (cache && cache.frontmatter && cache.frontmatterPosition) {
-                const { end } = cache.frontmatterPosition;
-                const body = content.substring(end.offset).trim();
-                let displayTitle = (cache.frontmatter.title as string | undefined) || file.basename;
-                if (Array.isArray(displayTitle)) displayTitle = (displayTitle as string[]).join(" ");
-
-                textToEmbed = `Title: ${displayTitle}\n\n${body}`;
+            if (cache?.frontmatter && cache.frontmatterPosition) {
+                const body = content.substring(cache.frontmatterPosition.end.offset).trim();
+                let title = (cache.frontmatter.title as unknown) || file.basename;
+                if (Array.isArray(title)) title = (title as string[]).join(" ");
+                textToEmbed = `Title: ${title as string}\n\n${body}`;
             } else {
                 textToEmbed = `Title: ${file.basename}\n\n${content}`;
             }
 
             if (!textToEmbed.trim()) {
-                this.deleteVector(file.path); // Just remove if empty
+                this.deleteVector(file.path);
                 return null;
             }
 
             logger.info(`Indexing: ${file.path}`);
-
-            // Embed Document now returns number[][]
             const embeddings = await this.embeddingService.embedDocument(textToEmbed, file.basename, priority);
 
-            this.upsertVector(file.path, file.stat.mtime, embeddings);
+            this.upsertVector(file.path, file.stat.mtime, file.stat.size, embeddings);
             void this.saveVectors();
-
             return embeddings;
-
         } catch (e: unknown) {
             const message = e instanceof Error ? e.message : String(e);
-            if (message.includes('429')) {
+            if (message.includes('429') || (typeof e === 'object' && e !== null && 'status' in e && (e as Record<string, unknown>).status === 429)) {
                 logger.warn(`Hit 429 for ${file.path}. Backoff.`);
                 this.triggerBackoff();
                 this.requestQueue.unshift(async () => {
-                    await this.indexFileImmediate(file);
+                    await this.indexFileImmediate(file, priority);
                 });
             } else {
-                logger.error(`[VectorStore] Failed to index file "${file.path}": ${message}`, e);
+                logger.error(`Failed to index "${file.path}": ${message}`, e);
             }
             throw e;
         }
     }
 
-    private upsertVector(path: string, mtime: number, newVectors: number[][]) {
+    private upsertVector(path: string, mtime: number, size: number, newVectors: number[][]) {
         if (newVectors.length === 0) return;
-
         const dims = this.index.dimensions;
-        if (newVectors[0]!.length !== dims) {
-            if (!this.isReindexing) {
-                logger.error(`Dimension mismatch! Expected ${dims}, got ${newVectors[0]!.length}. Model in index: ${this.index.embeddingModel}. Current service model: ${this.embeddingService.modelName}`);
-            }
-            return;
-        }
-
-        // 1. Remove existing vectors for this file (always replace logic)
-        // This keeps logic simple and avoids fragmentation within a file's chunks
         this.deleteVector(path);
-
-        // 2. Normalize and Append
         newVectors.forEach(v => this.normalizeInPlace(v));
 
         const startId = this.vectorIdToPath.length;
         const newIds: number[] = [];
+        const requiredSize = (startId + newVectors.length) * dims;
 
-        const totalNewFloats = newVectors.length * dims;
-
-        // Ensure buffer space
-        const requiredSize = (startId * dims) + totalNewFloats;
-        // Optimization: Use capacity-based growth to avoid frequent re-allocations
         if (this.vectors.length < requiredSize) {
-            // Grow to next power of 2 or at least 50% larger than required for smoothing
-            const currentLogicalSize = startId * dims;
-            const newCapacity = Math.max(requiredSize, currentLogicalSize * 1.5);
-            const newBuffer = new Float32Array(Math.ceil(newCapacity));
-            newBuffer.set(this.vectors.subarray(0, currentLogicalSize));
+            const newBuffer = new Float32Array(Math.ceil(requiredSize * 1.5));
+            newBuffer.set(this.vectors.subarray(0, startId * dims));
             this.vectors = newBuffer;
         }
 
         for (let i = 0; i < newVectors.length; i++) {
-            const vec = newVectors[i]!;
-            this.vectors.set(vec, (startId + i) * dims);
+            this.vectors.set(newVectors[i]!, (startId + i) * dims);
             newIds.push(startId + i);
-            // Reverse index update
             this.vectorIdToPath[startId + i] = path;
         }
 
-        // 3. Update Index Entry
-        this.index.files[path] = {
-            ids: newIds,
-            mtime: mtime,
-            path: path
-        };
+        this.index.files[path] = { ids: newIds, mtime, size, path };
         this.isDirty = true;
     }
 
@@ -536,117 +431,46 @@ export class VectorStore {
         const entry = this.index.files[path];
         if (!entry) return;
 
-        // Assuming IDs are typically contiguous because of upsertVector approach,
-        // but robustly handle if they aren't (one by one deletion from end).
-        // Sorting IDs descending is critical to not invalidate indices of earlier removals in same batch operation...
-        // BUT, a standard splice affects everything after it.
-
-        // OPTIMIZED BATCH REMOVAL for Contiguous Block (Common case)
-        const ids = entry.ids.sort((a, b) => a - b);
-
-        const isContiguous = ids.length > 0 &&
-            (ids[ids.length - 1]! - ids[0]! + 1 === ids.length);
-
-        if (isContiguous && ids.length > 0) {
-            const startId = ids[0]!;
-            const count = ids.length;
+        const ids = entry.ids.sort((a, b) => b - a);
+        for (const id of ids) {
             const dims = this.index.dimensions;
+            if ((id + 1) * dims < this.vectors.length) {
+                this.vectors.copyWithin(id * dims, (id + 1) * dims);
+            }
+            this.vectors = this.vectors.subarray(0, this.vectors.length - dims);
+            this.vectorIdToPath.splice(id, 1);
 
-            // 1. Remove form vectors buffer
-            const removeStart = startId * dims;
-            const removeEnd = (startId + count) * dims;
-
-            // Manual partial shift is possibly faster/cleaner than creating new float32array every time?
-            // But creating new view is safer.
-            // Actually, we can just copy the tail over.
-            // Truncate (this reduces the length but keeps the backing buffer same size unless we slice)
-            // Actually, with our new startId = vectorIdToPath.length logic, 
-            // the spare capacity at the end is fine. 
-            // We just need to shift the data.
-            this.vectors.copyWithin(removeStart, removeEnd);
-
-            // We don't strictly need to subarray here because startId uses vectorIdToPath.length,
-            // but it helps keep it consistent if any other code uses this.vectors.length.
-            // Note: subarray is cheap (view only).
-            const nextCount = (this.vectorIdToPath.length - count);
-            this.vectors = this.vectors.subarray(0, nextCount * dims);
-
-            // 2. Remove from reverse index
-            this.vectorIdToPath.splice(startId, count);
-
-            // 3. Update all other IDs
-            // Since we removed `count` items at `startId`, all IDs >= `startId + count` (initially) shift down by `count`.
-            // With reverse index, we can iterate files or just reverse index?
-            // We need to update `index.files` entries. iterating entries is safest.
             for (const key in this.index.files) {
                 const f = this.index.files[key]!;
-                // Mutate the array
-                for (let i = 0; i < f.ids.length; i++) {
-                    if (f.ids[i]! > startId) {
-                        f.ids[i]! -= count;
-                    }
+                for (let k = 0; k < f.ids.length; k++) {
+                    if (f.ids[k]! > id) f.ids[k]!--;
                 }
             }
-        } else {
-            // Fallback: Delete one by one backwards
-            // If we delete largest ID first, it doesn't affect smaller IDs?
-            // Deleting ID 100 shifts 101+. ID 50 is unaffected.
-            // So iterating descending is correct.
-            for (let i = ids.length - 1; i >= 0; i--) {
-                this.deleteSingleId(ids[i]!);
-            }
         }
 
         delete this.index.files[path];
         this.isDirty = true;
     }
 
-    private deleteSingleId(id: number) {
-        const dims = this.index.dimensions;
-        const removeStart = id * dims;
-        const removeEnd = removeStart + dims;
-
-        if (removeEnd < this.vectors.length) {
-            this.vectors.copyWithin(removeStart, removeEnd);
-        }
-        this.vectors = this.vectors.subarray(0, this.vectors.length - dims);
-        this.vectorIdToPath.splice(id, 1);
-
-        for (const key in this.index.files) {
-            const f = this.index.files[key]!;
-            for (let k = 0; k < f.ids.length; k++) {
-                if (f.ids[k]! > id) f.ids[k]!--;
-            }
-        }
-    }
-
     public async renameVector(oldPath: string, newPath: string) {
         const entry = this.index.files[oldPath];
         if (!entry) return;
-
-        logger.info(`Renaming vector from ${oldPath} to ${newPath}`);
         this.index.files[newPath] = { ...entry, path: newPath };
         delete this.index.files[oldPath];
-
-        // Update reverse index
-        entry.ids.forEach(id => {
-            this.vectorIdToPath[id] = newPath;
-        });
-
+        entry.ids.forEach(id => this.vectorIdToPath[id] = newPath);
         await this.saveVectors();
     }
 
     private triggerBackoff() {
         if (this.isBackingOff) return;
         this.isBackingOff = true;
-        this.currentDelayMs = 30000;
-
+        this.currentDelayMs = EMBEDDING_CONSTANTS.BACKOFF_DELAY_MS;
         const timer = setTimeout(() => {
             this.activeTimers.delete(timer);
             this.isBackingOff = false;
             logger.info("Resuming queue after backoff.");
             void this.processQueue();
-        }, 60000);
+        }, EMBEDDING_CONSTANTS.RESUME_TIMEOUT_MS);
         this.activeTimers.add(timer);
     }
 
@@ -664,64 +488,36 @@ export class VectorStore {
     }
 
     public getVector(path: string): number[] | null {
-        // Return first vector for debugging/compatibility? 
-        // Or change signature? Use case: getting vector for similarity?
-        // Usually we don't retrieve single file vector externally. SImilarity uses internal buffer.
         const entry = this.index.files[path];
         if (!entry || entry.ids.length === 0) return null;
-
-        const id = entry.ids[0]!;
-        const start = id * this.index.dimensions;
+        const start = entry.ids[0]! * this.index.dimensions;
         return Array.from(this.vectors.slice(start, start + this.index.dimensions));
     }
 
     public findSimilar(queryVector: number[], limit?: number, threshold?: number, excludePath?: string): { path: string; score: number }[] {
-        const startTime = Date.now();
         const query = new Float32Array(queryVector);
         this.normalizeInPlace(query);
 
         const minScore = threshold ?? this.minSimilarityScore;
         const finalLimit = limit ?? this.similarNotesLimit;
-        const count = this.vectorIdToPath.length;
-
-        const scores: { path: string, score: number }[] = [];
-        // Track best score per path to support multi-vector matches (MaxSim)
         const bestScoreByPath = new Map<string, number>();
-
         const dims = this.index.dimensions;
-        const vectors = this.vectors;
-        const vectorIdToPath = this.vectorIdToPath;
-
-        for (let i = 0; i < count; i++) {
-            const start = i * dims;
 
-            // Inline dot product for maximum speed
+        for (let i = 0; i < this.vectorIdToPath.length; i++) {
             let score = 0;
-            for (let j = 0; j < dims; j++) {
-                score += query[j]! * vectors[start + j]!;
-            }
+            const start = i * dims;
+            for (let j = 0; j < dims; j++) score += query[j]! * this.vectors[start + j]!;
 
             if (score >= minScore) {
-                const path = vectorIdToPath[i];
+                const path = this.vectorIdToPath[i];
                 if (path && path !== excludePath) {
-                    const existing = bestScoreByPath.get(path) ?? -1;
-                    if (score > existing) {
-                        bestScoreByPath.set(path, score);
-                    }
+                    bestScoreByPath.set(path, Math.max(bestScoreByPath.get(path) ?? -1, score));
                 }
             }
         }
 
-        // Convert Map to Array
-        for (const [path, score] of bestScoreByPath.entries()) {
-            scores.push({ path, score });
-        }
-
+        const scores = Array.from(bestScoreByPath.entries()).map(([path, score]) => ({ path, score }));
         scores.sort((a, b) => b.score - a.score);
-
-        const result = (finalLimit > 0) ? scores.slice(0, finalLimit) : scores;
-        logger.debug(`findSimilar took ${Date.now() - startTime}ms for ${count} vectors. Results: ${result.length}`);
-        return result;
+        return finalLimit > 0 ? scores.slice(0, finalLimit) : scores;
     }
-
 }
\ No newline at end of file
diff --git a/src/settings/sections/models.ts b/src/settings/sections/models.ts
index b0b2ac9..a934dd5 100644
--- a/src/settings/sections/models.ts
+++ b/src/settings/sections/models.ts
@@ -1,7 +1,12 @@
 import { Setting, Notice, Plugin, App, setIcon } from "obsidian";
 import { IVaultIntelligencePlugin, DEFAULT_SETTINGS } from "../types";
-// Import the class value (not just type) for instanceof check
 import { LocalEmbeddingService } from "../../services/LocalEmbeddingService";
+import {
+    ModelRegistry,
+    LOCAL_EMBEDDING_MODELS,
+    GEMINI_CHAT_MODELS,
+    GEMINI_GROUNDING_MODELS
+} from "../../services/ModelRegistry";
 
 interface InternalApp extends App {
     setting: {
@@ -9,20 +14,6 @@ interface InternalApp extends App {
     };
 }
 
-// Model Defaults
-export const MODELS = {
-    SMALL: 'MinishLab/potion-base-8M',
-    BALANCED: 'Xenova/bge-small-en-v1.5',
-    ADVANCED: 'Xenova/nomic-embed-text-v1'
-};
-
-export const MODEL_LABELS = {
-    SMALL: 'Small (Potion-8M) - 256d [~15MB]',
-    BALANCED: 'Balanced (BGE-Small) - 384d [~30MB]',
-    ADVANCED: 'Advanced (Nomic-Embed) - 768d [~130MB]',
-    CUSTOM: 'Custom (HuggingFace ID)...'
-};
-
 export function renderModelSettings(containerEl: HTMLElement, plugin: IVaultIntelligencePlugin): void {
     new Setting(containerEl).setName('Models').setHeading();
 
@@ -38,20 +29,21 @@ export function renderModelSettings(containerEl: HTMLElement, plugin: IVaultInte
             .addOption('gemini', 'Google Gemini')
             .addOption('local', 'Transformers.js (local)')
             .setValue(plugin.settings.embeddingProvider)
-            .onChange(async (value) => {
-                plugin.settings.embeddingProvider = value as 'gemini' | 'local';
-
-                if (value === 'local') {
-                    plugin.settings.embeddingModel = 'Xenova/all-MiniLM-L6-v2';
-                    plugin.settings.embeddingDimension = 384;
-                } else {
-                    plugin.settings.embeddingModel = DEFAULT_SETTINGS.embeddingModel;
-                    plugin.settings.embeddingDimension = DEFAULT_SETTINGS.embeddingDimension;
-                }
+            .onChange((value) => {
+                void (async () => {
+                    const provider = value as 'gemini' | 'local';
+                    plugin.settings.embeddingProvider = provider;
 
-                await plugin.saveSettings();
-                refreshSettings(plugin);
-                new Notice("Provider changed. Please restart the plugin.");
+                    const defaultModelId = ModelRegistry.getDefaultModel('embedding', provider);
+                    const modelDef = ModelRegistry.getModelById(defaultModelId);
+
+                    plugin.settings.embeddingModel = defaultModelId;
+                    plugin.settings.embeddingDimension = modelDef?.dimensions ?? 768;
+
+                    await plugin.saveSettings();
+                    refreshSettings(plugin);
+                    new Notice("Provider changed. Please restart the plugin.");
+                })();
             }));
 
     // WARNING BOX for Local Models
@@ -71,31 +63,36 @@ export function renderModelSettings(containerEl: HTMLElement, plugin: IVaultInte
         embeddingSetting.addText(text => text
             .setPlaceholder(DEFAULT_SETTINGS.embeddingModel)
             .setValue(plugin.settings.embeddingModel)
-            .onChange(async (value) => {
-                plugin.settings.embeddingModel = value;
-                await plugin.saveSettings();
+            .onChange((value) => {
+                void (async () => {
+                    plugin.settings.embeddingModel = value;
+                    await plugin.saveSettings();
+                })();
             }));
     } else {
         embeddingSetting.addDropdown(dropdown => {
-            dropdown.addOption(MODELS.SMALL, MODEL_LABELS.SMALL);
-            dropdown.addOption(MODELS.BALANCED, MODEL_LABELS.BALANCED);
-            dropdown.addOption(MODELS.ADVANCED, MODEL_LABELS.ADVANCED);
-            dropdown.addOption('custom', MODEL_LABELS.CUSTOM);
+            for (const m of LOCAL_EMBEDDING_MODELS) {
+                dropdown.addOption(m.id, m.label);
+            }
+            dropdown.addOption('custom', 'Custom (HuggingFace ID)...');
 
             const current = plugin.settings.embeddingModel;
-            const isPreset = Object.values(MODELS).includes(current);
+            const isPreset = LOCAL_EMBEDDING_MODELS.some(m => m.id === current);
             dropdown.setValue(isPreset ? current : 'custom');
 
-            dropdown.onChange(async (val) => {
-                if (val !== 'custom') {
-                    plugin.settings.embeddingModel = val;
-                    if (val === MODELS.SMALL) plugin.settings.embeddingDimension = 256;
-                    if (val === MODELS.BALANCED) plugin.settings.embeddingDimension = 384;
-                    if (val === MODELS.ADVANCED) plugin.settings.embeddingDimension = 768;
+            dropdown.onChange((val) => {
+                void (async () => {
+                    if (val !== 'custom') {
+                        const modelDef = LOCAL_EMBEDDING_MODELS.find(m => m.id === val);
+                        plugin.settings.embeddingModel = val;
+                        if (modelDef?.dimensions) {
+                            plugin.settings.embeddingDimension = modelDef.dimensions;
+                        }
 
-                    await plugin.saveSettings();
-                }
-                refreshSettings(plugin);
+                        await plugin.saveSettings();
+                    }
+                    refreshSettings(plugin);
+                })();
             });
         });
     }
@@ -110,12 +107,14 @@ export function renderModelSettings(containerEl: HTMLElement, plugin: IVaultInte
         .addText(text => text
             .setPlaceholder(String(DEFAULT_SETTINGS.indexingDelayMs))
             .setValue(String(plugin.settings.indexingDelayMs))
-            .onChange(async (value) => {
-                const num = parseInt(value);
-                if (!isNaN(num)) {
-                    plugin.settings.indexingDelayMs = num;
-                    await plugin.saveSettings();
-                }
+            .onChange((value) => {
+                void (async () => {
+                    const num = parseInt(value);
+                    if (!isNaN(num)) {
+                        plugin.settings.indexingDelayMs = num;
+                        await plugin.saveSettings();
+                    }
+                })();
             }));
 
     new Setting(containerEl)
@@ -124,18 +123,20 @@ export function renderModelSettings(containerEl: HTMLElement, plugin: IVaultInte
         .addText(text => text
             .setPlaceholder(String(DEFAULT_SETTINGS.queueDelayMs))
             .setValue(String(plugin.settings.queueDelayMs))
-            .onChange(async (value) => {
-                const num = parseInt(value);
-                if (!isNaN(num)) {
-                    plugin.settings.queueDelayMs = num;
-                    await plugin.saveSettings();
-                }
+            .onChange((value) => {
+                void (async () => {
+                    const num = parseInt(value);
+                    if (!isNaN(num)) {
+                        plugin.settings.queueDelayMs = num;
+                        await plugin.saveSettings();
+                    }
+                })();
             }));
 
     // --- 2a. Custom Model Fields (Only if Local + Custom) ---
     const isLocal = plugin.settings.embeddingProvider === 'local';
     const currentModel = plugin.settings.embeddingModel;
-    const isCustom = isLocal && !Object.values(MODELS).includes(currentModel);
+    const isCustom = isLocal && !LOCAL_EMBEDDING_MODELS.some(m => m.id === currentModel);
 
     if (isCustom) {
         new Setting(containerEl)
@@ -143,32 +144,36 @@ export function renderModelSettings(containerEl: HTMLElement, plugin: IVaultInte
             .setDesc('HuggingFace model ID (e.g. "Xenova/paraphrase-multilingual-MiniLM-L12-v2"). Must be ONNX compatible.')
             .addText(text => text
                 .setValue(plugin.settings.embeddingModel)
-                .onChange(async (value) => {
-                    plugin.settings.embeddingModel = value;
-                    await plugin.saveSettings();
+                .onChange((value) => {
+                    void (async () => {
+                        plugin.settings.embeddingModel = value;
+                        await plugin.saveSettings();
+                    })();
                 }))
             .addButton(btn => btn
                 .setButtonText("Validate")
-                .onClick(async () => {
-                    btn.setDisabled(true);
-                    btn.setButtonText("Checking...");
-
-                    const { validateModel } = await import("../../utils/validation");
-                    const result = await validateModel(plugin.settings.embeddingModel);
-
-                    if (result.valid) {
-                        new Notice(`Model Valid! ${result.recommendedDims ? `Dims: ${result.recommendedDims}` : ''}`);
-                        if (result.recommendedDims) {
-                            plugin.settings.embeddingDimension = result.recommendedDims;
-                            await plugin.saveSettings();
-                            refreshSettings(plugin);
+                .onClick(() => {
+                    void (async () => {
+                        btn.setDisabled(true);
+                        btn.setButtonText("Checking...");
+
+                        const { validateModel } = await import("../../utils/validation");
+                        const result = await validateModel(plugin.settings.embeddingModel);
+
+                        if (result.valid) {
+                            new Notice(`Model Valid! ${result.recommendedDims ? `Dims: ${result.recommendedDims}` : ''}`);
+                            if (result.recommendedDims) {
+                                plugin.settings.embeddingDimension = result.recommendedDims;
+                                await plugin.saveSettings();
+                                refreshSettings(plugin);
+                            }
+                        } else {
+                            new Notice(`Invalid Model: ${result.reason}`, 5000);
                         }
-                    } else {
-                        new Notice(`Invalid Model: ${result.reason}`, 5000);
-                    }
 
-                    btn.setDisabled(false);
-                    btn.setButtonText("Validate");
+                        btn.setDisabled(false);
+                        btn.setButtonText("Validate");
+                    })();
                 }));
 
         new Setting(containerEl)
@@ -176,12 +181,14 @@ export function renderModelSettings(containerEl: HTMLElement, plugin: IVaultInte
             .setDesc('The output vector size of this model (e.g. 384, 768). Incorrect values will break search.')
             .addText(text => text
                 .setValue(String(plugin.settings.embeddingDimension))
-                .onChange(async (value) => {
-                    const num = parseInt(value);
-                    if (!isNaN(num)) {
-                        plugin.settings.embeddingDimension = num;
-                        await plugin.saveSettings();
-                    }
+                .onChange((value) => {
+                    void (async () => {
+                        const num = parseInt(value);
+                        if (!isNaN(num)) {
+                            plugin.settings.embeddingDimension = num;
+                            await plugin.saveSettings();
+                        }
+                    })();
                 }));
     }
 
@@ -194,21 +201,23 @@ export function renderModelSettings(containerEl: HTMLElement, plugin: IVaultInte
                 .setButtonText('Force re-download')
                 .setIcon('refresh-cw')
                 .setWarning()
-                .onClick(async () => {
-                    const pluginWithService = plugin as unknown as { embeddingService?: unknown };
-                    const service = pluginWithService.embeddingService;
+                .onClick(() => {
+                    void (async () => {
+                        const pluginWithService = plugin as unknown as { embeddingService?: unknown };
+                        const service = pluginWithService.embeddingService;
 
-                    if (service instanceof LocalEmbeddingService) {
-                        btn.setDisabled(true);
-                        btn.setButtonText("Downloading...");
+                        if (service instanceof LocalEmbeddingService) {
+                            btn.setDisabled(true);
+                            btn.setButtonText("Downloading...");
 
-                        await service.forceRedownload();
+                            await service.forceRedownload();
 
-                        btn.setDisabled(false);
-                        btn.setButtonText("Force re-download");
-                    } else {
-                        new Notice("Local embedding service is not active");
-                    }
+                            btn.setDisabled(false);
+                            btn.setButtonText("Force re-download");
+                        } else {
+                            new Notice("Local embedding service is not active");
+                        }
+                    })();
                 }));
     }
 
@@ -218,34 +227,65 @@ export function renderModelSettings(containerEl: HTMLElement, plugin: IVaultInte
         .addButton(btn => btn
             .setButtonText('Re-index vault')
             .setTooltip('Wipes all vector data and starts fresh')
-            .onClick(async () => {
-                if (btn.buttonEl.textContent === 'Re-index vault') {
-                    btn.setButtonText('Confirm re-index?');
-                    btn.setWarning();
-                    setTimeout(() => {
-                        if (btn.buttonEl.textContent === 'Confirm re-index?') {
-                            btn.setButtonText('Re-index vault');
-                            btn.buttonEl.classList.remove('mod-warning');
-                        }
-                    }, 5000);
-                } else {
-                    await plugin.vectorStore.reindexVault();
-                    btn.setButtonText('Re-index vault');
-                    btn.buttonEl.classList.remove('mod-warning');
-                }
+            .onClick(() => {
+                void (async () => {
+                    if (btn.buttonEl.textContent === 'Re-index vault') {
+                        btn.setButtonText('Confirm re-index?');
+                        btn.setWarning();
+                        setTimeout(() => {
+                            if (btn.buttonEl.textContent === 'Confirm re-index?') {
+                                btn.setButtonText('Re-index vault');
+                                btn.buttonEl.classList.remove('mod-warning');
+                            }
+                        }, 5000);
+                    } else {
+                        await plugin.vectorStore.reindexVault();
+                        btn.setButtonText('Re-index vault');
+                        btn.buttonEl.classList.remove('mod-warning');
+                    }
+                })();
             }));
 
     // --- 3. Chat Model ---
+    const chatModelCurrent = plugin.settings.chatModel;
+    const isChatPreset = GEMINI_CHAT_MODELS.some(m => m.id === chatModelCurrent);
+
     new Setting(containerEl)
         .setName('Chat model')
         .setDesc('Main model used for reasoning and answering questions.')
-        .addText(text => text
-            .setPlaceholder(DEFAULT_SETTINGS.chatModel)
-            .setValue(plugin.settings.chatModel)
-            .onChange(async (value) => {
-                plugin.settings.chatModel = value;
-                await plugin.saveSettings();
-            }));
+        .addDropdown(dropdown => {
+            for (const m of GEMINI_CHAT_MODELS) {
+                dropdown.addOption(m.id, m.label);
+            }
+            dropdown.addOption('custom', 'Custom model string...');
+
+            dropdown.setValue(isChatPreset ? chatModelCurrent : 'custom');
+
+            dropdown.onChange((val) => {
+                void (async () => {
+                    if (val !== 'custom') {
+                        plugin.settings.chatModel = val;
+                        await plugin.saveSettings();
+                    }
+                    refreshSettings(plugin);
+                })();
+            });
+        });
+
+    if (!isChatPreset) {
+        new Setting(containerEl)
+            .setName('Custom chat model')
+            .setDesc('Enter the specific Gemini model ID.')
+            .addText(text => text
+                .setPlaceholder(DEFAULT_SETTINGS.chatModel)
+                .setValue(chatModelCurrent)
+                .onChange((value) => {
+                    void (async () => {
+                        plugin.settings.chatModel = value;
+                        await plugin.saveSettings();
+                    })();
+                }));
+    }
 
     new Setting(containerEl)
         .setName('Context window budget')
@@ -253,25 +293,56 @@ export function renderModelSettings(containerEl: HTMLElement, plugin: IVaultInte
         .addText(text => text
             .setPlaceholder(String(DEFAULT_SETTINGS.contextWindowTokens))
             .setValue(String(plugin.settings.contextWindowTokens))
-            .onChange(async (value) => {
-                const num = parseInt(value);
-                if (!isNaN(num) && num > 0) {
-                    plugin.settings.contextWindowTokens = num;
-                    await plugin.saveSettings();
-                }
+            .onChange((value) => {
+                void (async () => {
+                    const num = parseInt(value);
+                    if (!isNaN(num) && num > 0) {
+                        plugin.settings.contextWindowTokens = num;
+                        await plugin.saveSettings();
+                    }
+                })();
             }));
 
     // 4. Grounding Model
+    const groundingModelCurrent = plugin.settings.groundingModel;
+    const isGroundingPreset = GEMINI_GROUNDING_MODELS.some(m => m.id === groundingModelCurrent);
+
     new Setting(containerEl)
         .setName('Grounding model')
-        .setDesc(`The fast, cost-effective model used specifically for web searches (e.g., \`${DEFAULT_SETTINGS.groundingModel}\`).`)
-        .addText(text => text
-            .setPlaceholder(DEFAULT_SETTINGS.groundingModel)
-            .setValue(plugin.settings.groundingModel)
-            .onChange(async (value) => {
-                plugin.settings.groundingModel = value;
-                await plugin.saveSettings();
-            }));
+        .setDesc(`The fast, cost-effective model used specifically for web searches.`)
+        .addDropdown(dropdown => {
+            for (const m of GEMINI_GROUNDING_MODELS) {
+                dropdown.addOption(m.id, m.label);
+            }
+            dropdown.addOption('custom', 'Custom model string...');
+
+            dropdown.setValue(isGroundingPreset ? groundingModelCurrent : 'custom');
+
+            dropdown.onChange((val) => {
+                void (async () => {
+                    if (val !== 'custom') {
+                        plugin.settings.groundingModel = val;
+                        await plugin.saveSettings();
+                    }
+                    refreshSettings(plugin);
+                })();
+            });
+        });
+
+    if (!isGroundingPreset) {
+        new Setting(containerEl)
+            .setName('Custom grounding model')
+            .setDesc('Enter the specific Gemini model ID.')
+            .addText(text => text
+                .setPlaceholder(DEFAULT_SETTINGS.groundingModel)
+                .setValue(groundingModelCurrent)
+                .onChange((value) => {
+                    void (async () => {
+                        plugin.settings.groundingModel = value;
+                        await plugin.saveSettings();
+                    })();
+                }));
+    }
 
     // 5. Code Model & Execution Toggle
     new Setting(containerEl)
@@ -279,23 +350,54 @@ export function renderModelSettings(containerEl: HTMLElement, plugin: IVaultInte
         .setDesc('Enable a specialized sub-agent that uses code to solve math problems and complex logic.')
         .addToggle(toggle => toggle
             .setValue(plugin.settings.enableCodeExecution)
-            .onChange(async (value) => {
-                plugin.settings.enableCodeExecution = value;
-                await plugin.saveSettings();
-                refreshSettings(plugin);
+            .onChange((value) => {
+                void (async () => {
+                    plugin.settings.enableCodeExecution = value;
+                    await plugin.saveSettings();
+                    refreshSettings(plugin);
+                })();
             }));
 
     if (plugin.settings.enableCodeExecution) {
+        const codeModelCurrent = plugin.settings.codeModel;
+        const isCodePreset = GEMINI_CHAT_MODELS.some(m => m.id === codeModelCurrent);
+
         new Setting(containerEl)
             .setName('Code model')
-            .setDesc(`The model used for code execution (e.g., \`${DEFAULT_SETTINGS.codeModel}\`).`)
-            .addText(text => text
-                .setPlaceholder(DEFAULT_SETTINGS.codeModel)
-                .setValue(plugin.settings.codeModel)
-                .onChange(async (value) => {
-                    plugin.settings.codeModel = value;
-                    await plugin.saveSettings();
-                }));
+            .setDesc(`The model used for code execution.`)
+            .addDropdown(dropdown => {
+                for (const m of GEMINI_CHAT_MODELS) {
+                    dropdown.addOption(m.id, m.label);
+                }
+                dropdown.addOption('custom', 'Custom model string...');
+
+                dropdown.setValue(isCodePreset ? codeModelCurrent : 'custom');
+
+                dropdown.onChange((val) => {
+                    void (async () => {
+                        if (val !== 'custom') {
+                            plugin.settings.codeModel = val;
+                            await plugin.saveSettings();
+                        }
+                        refreshSettings(plugin);
+                    })();
+                });
+            });
+
+        if (!isCodePreset) {
+            new Setting(containerEl)
+                .setName('Custom code model')
+                .setDesc('Enter the specific Gemini model ID.')
+                .addText(text => text
+                    .setPlaceholder(DEFAULT_SETTINGS.codeModel)
+                    .setValue(codeModelCurrent)
+                    .onChange((value) => {
+                        void (async () => {
+                            plugin.settings.codeModel = value;
+                            await plugin.saveSettings();
+                        })();
+                    }));
+        }
     }
 }
 
diff --git a/src/workers/embedding.worker.ts b/src/workers/embedding.worker.ts
index 3209303..8ebc2c6 100644
--- a/src/workers/embedding.worker.ts
+++ b/src/workers/embedding.worker.ts
@@ -31,14 +31,8 @@ if (!safeEnv.backends) safeEnv.backends = {};
 if (!safeEnv.backends.onnx) safeEnv.backends.onnx = {};
 if (!safeEnv.backends.onnx.wasm) safeEnv.backends.onnx.wasm = {};
 
-// Explicit CDN Paths
-const CDN_URL = 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2/dist/';
-safeEnv.backends.onnx.wasm.wasmPaths = {
-    'ort-wasm.wasm': `${CDN_URL}ort-wasm.wasm`,
-    'ort-wasm-simd.wasm': `${CDN_URL}ort-wasm-simd.wasm`,
-    'ort-wasm-threaded.wasm': `${CDN_URL}ort-wasm-threaded.wasm`,
-    'ort-wasm-simd-threaded.wasm': `${CDN_URL}ort-wasm-simd-threaded.wasm`,
-};
+// Initialized with dummy values, will be set via 'configure' message
+safeEnv.backends.onnx.wasm.wasmPaths = {};
 
 safeEnv.backends.onnx.wasm.numThreads = 1; // Default to safe single thread
 safeEnv.backends.onnx.wasm.simd = true;
@@ -111,6 +105,8 @@ interface ConfigureMessage {
     type: 'configure';
     numThreads: number;
     simd: boolean;
+    cdnUrl?: string; // NEW
+    version?: string; // NEW
 }
 
 interface EmbedMessage {
@@ -349,6 +345,19 @@ ctx.addEventListener('message', (event: MessageEvent) => {
 
         if ('type' in data && (data as { type: string }).type === 'configure') {
             const config = data as ConfigureMessage;
+
+            // Set dynamic CDN paths if provided
+            if (config.cdnUrl) {
+                const baseUrl = config.cdnUrl.endsWith('/') ? config.cdnUrl : `${config.cdnUrl}/`;
+                safeEnv.backends!.onnx!.wasm!.wasmPaths = {
+                    'ort-wasm.wasm': `${baseUrl}ort-wasm.wasm`,
+                    'ort-wasm-simd.wasm': `${baseUrl}ort-wasm-simd.wasm`,
+                    'ort-wasm-threaded.wasm': `${baseUrl}ort-wasm-threaded.wasm`,
+                    'ort-wasm-simd-threaded.wasm': `${baseUrl}ort-wasm-simd-threaded.wasm`,
+                };
+                logger.info(`[Worker] CDN set to: ${baseUrl}`);
+            }
+
             if (safeEnv.backends!.onnx!.wasm!.numThreads !== config.numThreads || safeEnv.backends!.onnx!.wasm!.simd !== config.simd) {
                 logger.debug(`[Worker] Configuration changed. Resetting pipeline instance.`);
                 PipelineSingleton.instance = null;
